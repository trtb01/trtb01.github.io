<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base64 File Converter & Encrypter</title>
    <style>
        /* --- CSS Variables --- */
        :root {
            --line-thick: 1px;       /* Global variable for line thickness */
            --page-paddi: 5%;        /* Padding around the entire page */
            --min-gap: 5px;          /* Minimal padding for content inside borders */
            --tight-line: 1.0;       /* Very tight vertical spacing for text */
            --font-size0: 16px;      /* Base font size for all text */
            --indentatio: 3rem;      /* Equivalent to ~0.5 inches */
            --slim-v-mar: 0.5%;      /* Very very slim vertical margins for blocks */
            --hr-v-margi: 2%;        /* Slightly more visible margin for HR */
            --para-inden: 2ch;       /* First line of paragraph indented 2 characters */
            --head-inden: 4ch;       /* Headers indented 4 characters */
        }

        /* --- General Styling --- */
        body {
            background-color: black;
            color: white;
            font-family: monospace;
            font-size: var(--font-size0);
            line-height: var(--tight-line);
            margin: 0;
            padding: var(--page-paddi);
            box-sizing: border-box;
        }

        /* --- Paragraphs --- */
        p {
            margin: var(--slim-v-mar) 0;
            text-indent: var(--para-inden);
        }

        /* --- Headers --- */
        h1, h2, h3, h4, h5, h6 {
            background-color: red;
            color: black;
            font-size: inherit;
            margin-top: 0;
            margin-bottom: 0;
            margin-left: var(--head-inden);
            padding: 5px 10px;
            display: inline-block;
            line-height: var(--tight-line);
        }

        /* --- Links --- */
        a {
            color: white;
            text-decoration: none;
            text-decoration-line: overline;
            text-decoration-color: red;
            text-decoration-thickness: var(--line-thick);
            padding: 2px 4px;
            transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out;
        }

        a:hover {
            background-color: white;
            color: black;
        }

        /* --- Emphasis (.em class) --- */
        .em {
            color: red;
        }

        /* --- Code Blocks (pre, code) --- */
        pre, code {
            background-color: black;
            color: white;
            border: var(--line-thick) solid white;
            padding: var(--min-gap);
            margin: var(--slim-v-mar) 0;
            display: block;
            overflow-x: auto;
            box-sizing: border-box;
            font-size: var(--font-size0);
            line-height: var(--tight-line);
        }

        :not(pre) > code {
            border-top: none;
            border-bottom: none;
            border-left: var(--line-thick) solid white;
            border-right: var(--line-thick) solid white;
            padding: 0 3px;
            display: inline-block;
            vertical-align: middle;
            line-height: inherit;
        }

        /* --- Form Elements --- */
        input, textarea, select, button {
            background-color: black;
            color: red;
            border: var(--line-thick) solid white;
            padding: 5px;
            font-family: monospace;
            font-size: var(--font-size0);
            box-sizing: border-box;
            line-height: var(--tight-line);
            margin: var(--slim-v-mar) 0;
            display: block;
            width: 100%;
        }

        input:focus, textarea:focus, select:focus, button:focus {
            border-color: red;
            outline: none;
        }
        
        button {
            cursor: pointer;
        }
        
        button:hover {
            background-color: red;
            color: black;
        }

        /* --- Fieldset & Legend (New for Phase 1) --- */
        fieldset {
            border: var(--line-thick) solid white;
            margin: var(--slim-v-mar) 0;
            padding: var(--min-gap);
        }

        legend {
            color: red;
            padding: 0 5px;
        }

        /* --- Horizontal Rule (hr) --- */
        hr {
            border: none;
            border-top: var(--line-thick) solid red;
            margin: var(--hr-v-margi) 0;
        }
        
        /* Utility for status messages */
        #status {
            color: red;
            font-style: italic;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <h1>FILE_PROCESSOR_V1</h1>
    <p>Upload a file to convert it to Base64 string format. Optionally, provide a passcode to encrypt the output using AES-GCM.</p>
    
    <hr>

    <label for="fileInput">Input Source:</label>
    <input type="file" id="fileInput">

    <!-- Phase 1: Compression Settings Fieldset -->
    <fieldset>
        <legend>Compression Settings</legend>

        <label for="formatSelect">Format Selection:</label>
        <select id="formatSelect">
            <option value="original">Original</option>
            <option value="image/jpeg">JPEG</option>
            <option value="image/webp" selected>WebP</option>
        </select>

        <label for="qualityRange">Compression Aggression (0.0 - 1.0):</label>
        <input type="range" id="qualityRange" min="0.0" max="1.0" step="0.1" value="0.7">

        <label for="maxDimensions">Max Width/Height (px):</label>
        <input type="number" id="maxDimensions" value="1024">

        <div id="visualFeedback" style="margin-top: 5px; border-left: 1px solid red; padding-left: 5px;">
            Original Size: 0 KB | New Size: 0 KB
        </div>
    </fieldset>

    <label for="passcode">Encryption Passcode (Optional):</label>
    <input type="password" id="passcode" placeholder="Leave empty for plain Base64">

    <button id="convertBtn" onclick="processFile()">>> EXECUTE CONVERSION</button>

    <hr>

    <!-- Phase 5: Preview & Stats Area -->
    <div id="previewArea" style="display:none; border: var(--line-thick) solid white; padding: var(--min-gap); margin: var(--slim-v-mar) 0;">
        <div id="statsDetail" class="em" style="margin-bottom: 5px;"></div>
        <img id="imgPreview" src="" alt="Compressed Preview" style="max-width: 200px; display: block; border: 1px solid red;">
    </div>

    <label for="output">System Output:</label>
    <textarea id="output" rows="15" readonly placeholder="Waiting for input..."></textarea>
    
    <div id="status"></div>

    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button onclick="copyToClipboard()">[ COPY DATA ]</button>
        <button onclick="downloadOutput()">[ SAVE AS .TXT ]</button>
    </div>

    <script>
        // --- Main Logic ---

        async function processFile() {
            const fileInput = document.getElementById('fileInput');
            const passInput = document.getElementById('passcode');
            const status = document.getElementById('status');
            const output = document.getElementById('output');
            const previewArea = document.getElementById('previewArea');
            const statsDetail = document.getElementById('statsDetail');
            const imgPreview = document.getElementById('imgPreview');

            status.innerText = "Initializing...";
            output.value = "";
            previewArea.style.display = 'none';

            if (fileInput.files.length === 0) {
                status.innerText = "ERROR: No file selected.";
                return;
            }

            const file = fileInput.files[0];
            let base64String = "";
            let originalSizeBytes = file.size;
            let finalSizeBytes = 0;

            try {
                // Phase 4 & 5: Pipeline & Verification
                
                if (file.type.startsWith('image/')) {
                    status.innerText = "Compressing Image...";
                    
                    // Call the compression engine
                    base64String = await compressImage(file);

                    // Phase 5: Calculate Stats & Render Preview
                    // Approx size of base64 data in bytes = (length * 3/4)
                    finalSizeBytes = Math.round((base64String.length * 3) / 4);
                    const reductionPercent = ((1 - (finalSizeBytes / originalSizeBytes)) * 100).toFixed(2);
                    
                    // Render Preview
                    imgPreview.src = base64String;
                    statsDetail.innerText = `Original: ${(originalSizeBytes/1024).toFixed(2)} KB | Compressed: ${(finalSizeBytes/1024).toFixed(2)} KB | Reduced by ${reductionPercent}%`;
                    previewArea.style.display = 'block';
                    
                } else {
                    status.innerText = "Reading File...";
                    base64String = await readFileAsDataURL(file);
                    
                    // Update visuals for non-images
                    const kbytes = (file.size / 1024).toFixed(2);
                    document.getElementById('visualFeedback').innerText = 
                        `Original Size: ${kbytes} KB | New Size: ${kbytes} KB (Unchanged)`;
                }

                // 2. Check if Encryption is requested
                if (passInput.value.length > 0) {
                    status.innerText = "Encrypting data (AES-GCM)...";
                    const encryptedData = await encryptData(base64String, passInput.value);
                    output.value = encryptedData;
                    status.innerText = "SUCCESS: File processed, compressed, and encrypted.";
                } else {
                    status.innerText = "Finalizing Output...";
                    output.value = base64String;
                    status.innerText = "SUCCESS: File converted to Base64.";
                }
            } catch (err) {
                console.error(err);
                status.innerText = "CRITICAL ERROR: " + err.message;
            }
        }

        // --- Phase 2 & 3: Middleware Function ---
        async function compressImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const url = URL.createObjectURL(file);
                
                // Fetch User Settings
                const format = document.getElementById('formatSelect').value;
                const quality = parseFloat(document.getElementById('qualityRange').value);
                const maxDim = parseInt(document.getElementById('maxDimensions').value) || 1024;
                const feedback = document.getElementById('visualFeedback');

                img.onload = () => {
                    URL.revokeObjectURL(url);
                    
                    // --- Phase 3: Resize Logic ---
                    let width = img.naturalWidth;
                    let height = img.naturalHeight;

                    // Mathematical reduction of dimensions
                    if (width > maxDim || height > maxDim) {
                        if (width > height) {
                            height = Math.round((height * maxDim) / width);
                            width = maxDim;
                        } else {
                            width = Math.round((width * maxDim) / height);
                            height = maxDim;
                        }
                    }

                    // Create canvas with new dimensions
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw the image onto the canvas
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // --- Phase 3: Format Conversion & Quality Drop ---
                    let mimeType = format;
                    if (mimeType === 'original') {
                        mimeType = file.type;
                    }

                    // The "Extreme" Factor
                    const dataUrl = canvas.toDataURL(mimeType, quality);
                    
                    // Visual Feedback Logic (Immediate)
                    const originalSizeKB = (file.size / 1024).toFixed(2);
                    const newSizeKB = ((dataUrl.length * 0.75) / 1024).toFixed(2);
                    feedback.innerText = `Original Size: ${originalSizeKB} KB | New Size: ${newSizeKB} KB`;

                    resolve(dataUrl);
                };
                
                img.onerror = (error) => reject(new Error("Failed to load image for compression."));
                img.src = url;
            });
        }

        // --- Helper: Read File ---
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        // --- Helper: Copy ---
        function copyToClipboard() {
            const copyText = document.getElementById("output");
            copyText.select();
            copyText.setSelectionRange(0, 999999); /* For mobile devices */
            navigator.clipboard.writeText(copyText.value).then(() => {
                document.getElementById('status').innerText = "System: Copied to clipboard.";
            });
        }

        // --- Helper: Download ---
        function downloadOutput() {
            const text = document.getElementById("output").value;
            if(!text) return;
            
            const blob = new Blob([text], { type: "text/plain" });
            const anchor = document.createElement("a");
            anchor.download = "output_data.txt";
            anchor.href = window.URL.createObjectURL(blob);
            anchor.target = "_blank";
            anchor.style.display = "none";
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
        }

        // --- Encryption Logic (AES-GCM) ---
        
        async function encryptData(plainText, password) {
            const enc = new TextEncoder();
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            
            // Import Password
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw", 
                enc.encode(password), 
                { name: "PBKDF2" }, 
                false, 
                ["deriveKey"]
            );

            // Derive Key
            const key = await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );

            // Encrypt
            const encryptedContent = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                key,
                enc.encode(plainText)
            );

            // Pack Data: Salt + IV + Ciphertext -> Base64
            // We pack it all into a JSON object and base64 that so it's a single portable string
            const package = {
                s: bufferToBase64(salt),
                iv: bufferToBase64(iv),
                d: bufferToBase64(encryptedContent)
            };

            return btoa(JSON.stringify(package));
        }

        // ArrayBuffer to Base64 helper
        function bufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

    </script>
</body>
</html>
